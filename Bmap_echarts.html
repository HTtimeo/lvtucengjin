<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Bmap+echarts热力图</title>
    <style>
        html, body, #container {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            cursor: default;
        }
    </style>
</head>
<body>
<div id="container"></div>
<script src="lib/custom_map_config.js"></script>
<script type="text/javascript" src="lib/echarts.min.js"></script>
<script src='lib/kriging-original.js'></script>
<script type="text/javascript" src="lib/bmap.js"></script>
<script src="http://api.map.baidu.com/api?v=3.0&ak=qxtHlX3iHors0dHRMZE0N4OLE8Vu7wbH"></script>
<script src="lib/province.js"></script>
<script type="text/javascript">
    let map = null
    // $.ajaxSettings.async = false;    //(同步执行)   获取地图样式
    // $.get('lib/custom_map_config.json', function (data) {
    //     mapStyle = data
    // })
    // $.ajaxSettings.async = true;    //(异步执行)

    //克里金插值数据封装
    let paramsK={
        mapCenter:[114.360456, 30.538622],
        maxValue:100,
        krigingModel:'exponential',//model还可选'gaussian','spherical'
        krigingSigma2:0,
        krigingAlpha:100,
        canvasAlpha:0.5,//canvas图层透明度
        colors:["#006837", "#1a9850", "#66bd63", "#a6d96a", "#d9ef8b", "#ffffbf","#fee08b", "#fdae61", "#f46d43", "#d73027", "#a50026"],
    };
    //亳州                //六安                    //合肥                    //阜阳
    // let points=[[115.78919,33.863132],[116.515884,31.765982],[117.228779,31.826871],[115.807588,32.915904],[116.396301,32.877101]]
    let points=[]
    let values=[]
    let top1 = 34.758
    let bottom1 = 29.397
    let left1 = 114.884
    let right1 = 119.659
    function sum (m,n){
        return Math.random()*(m - n) + n;
    }
    let latArr = []
    let lengArr = []
    for (let i=0;i<350;i++){
        let lat = sum(bottom1,top1)
        latArr.push(lat)
        let lat2 = sum(left1,right1)
        lengArr.push(lat2)
        values.push(sum(1,80))
    }
    // latArr.forEach(function(v,i){
    //     points.push([lengArr[i],v])
    // })
    // console.log(points)

    //逆时针,左 下 右 上  (观测点最边缘的经纬度)
    let extent = [114.884,29.397,119.659,34.758]
    // let lngs=[],lats=[];
    let maxValue = getMaxMin(values,'max');
    let minValue = getMaxMin(values,'min');
    // points.forEach(function(v){
    //     lngs.push(v[0])
    //     lats.push(v[1])
    // })
    //变差图;取样间隔有关的变分量                  //"exponential", 0, 100
    let variogram=kriging.train(values,lengArr,latArr, paramsK.krigingModel,paramsK.krigingSigma2,paramsK.krigingAlpha);
    //绘制多边形
    let polygons=[];
    polygons.push([[extent[0],extent[1]],[extent[0],extent[3]],[extent[2],extent[3]],[extent[2],extent[1]]]);
    //范围经度右-范围经纬左
    // let grid=kriging.grid(world,variogram,(extent[2]-extent[0])/80);
    // 遍历world边界数据，生成scope边界线
    let world = []
    var positions = [];
    let anhui = province[0]  //安徽获取到6个边界,取最长的边界
    anhui.split(";").forEach(function (v) {
        let ll = v.split(",")
        positions.push([ll[0]*1,ll[1]*1])
    })
    world.push(positions)

    let grid=kriging.grid(world,variogram,(extent[2]-extent[0])/80);

    let myChart = echarts.init(document.getElementById("container"));
    let COLORS = ["rgba(0,0,0,0)","#006837", "#1a9850", "#66bd63", "#a6d96a", "#d9ef8b", "#ffffbf","#fee08b", "#fdae61", "#f46d43", "#d73027", "#a50026"]
    let lngExtent = [extent[1], extent[3]];
    let latExtent = [extent[0], extent[2]];
    let cellCount = [grid[0].length, grid.length];
    //单元格坐标
    let cellSizeCoord = [(latExtent[1] - latExtent[0]) / cellCount[1],(lngExtent[1] - lngExtent[0]) / cellCount[0]];
    let data = []
    for(let i=0;i<grid[0].length-1;i++){ //宽
        for(let j=0;j<grid.length-1;j++){  //高
            if(null == grid[j][i]){
                let d = [j,i,0]
                data.push(d);
            }else{
                let d = [j,i,grid[j][i].toFixed(0)]
                data.push(d);
            }
        }
    }
    // console.log(data)
    function renderItem(params, api) {
        let lngIndex = api.value(0);
        let latIndex = api.value(1);
        let pointLeftTop = getCoord(params, api, lngIndex, latIndex);
        let pointRightBottom = getCoord(params, api, lngIndex + 1, latIndex + 1);
        return {
            type: 'rect',
            shape: {
                x: pointLeftTop[0],
                y: pointLeftTop[1],
                width: pointRightBottom[0] - pointLeftTop[0],
                height: pointRightBottom[1] - pointLeftTop[1]
            },
            style: api.style({
                stroke: 'rgba(0,0,0,0)' //笔画,网格线
            }),
            styleEmphasis: api.styleEmphasis() //风格强调
        };
    }

    function getCoord(params, api, lngIndex, latIndex) {
        var coords = params.context.coords || (params.context.coords = []);
        var key = lngIndex + '-' + latIndex;

        // bmap returns point in integer, which makes cell width unstable.
        //返回整数形式的点，这使得单元格宽度不稳定。
        // let extent = [115.445966,29.406741,119.199014,34.51696]
        // let lngExtent = [extent[1], extent[3]];
        // let latExtent = [extent[0], extent[2]];
        // So we have to use right bottom point. 所以我们必须使用正确的底线
        return coords[key] || (coords[key] = api.coord([+(latExtent[0] + lngIndex * cellSizeCoord[0]).toFixed(6),+(lngExtent[0] + latIndex * cellSizeCoord[1]).toFixed(6)
        ]));
    }
    console.log(world)
    let dd = [{"name": "合肥","value": [117.27,31.86,229]}]
    option = {
        tooltip: {},
        visualMap: {
            inverse: true,
            top: 10,
            left: 10,
            min: 1,
            max: maxValue,
            inRange: {
                color: COLORS,
                opacity: 0.7
            }
        },
        bmap: {
            center: [117.283042, 31.86119],
            zoom: 8,
            roam: true,
            mapStyle: {styleJson:mapStyle}
        },
        series: [
            {
                type: 'custom',
                coordinateSystem: 'bmap',
                renderItem: renderItem,
                animation: false,
                emphasis: {//强调
                    itemStyle: {
                        color: 'yellow'
                    }
                },
                encode: {
                    tooltip: 2
                },
                data: data
            },
            {
                type: 'scatter',
                coordinateSystem: 'bmap',
                symbolSize: function (val) {
                    return val[2] / 10;
                },
                emphasis: {//强调
                    label: {
                        show: true
                    }
                },
                label: {
                    formatter: '{b}',
                    position: 'right',
                    show: false
                },
                encode: {
                    tooltip: 2
                },
                data:dd,
            },
            {
                type: 'lines',
                coordinateSystem: 'bmap',
                data: world,
                polyline: true,
                lineStyle: {
                    color: 'purple',
                    opacity: 0.6,
                    width: 1
                }
            },
        ],
    };
    myChart.setOption(option)
    // setTimeout(function(){
    //     getAera();
    //     addlabel();
    // });
    // 这里获取百度地图对象，用这个对象以后可以使用百度地图API操作地图，获取到对象就可以添加标注，设置监听了**
    map = myChart.getModel().getComponent('bmap').getBMap();
    var scaleCtrl = new BMap.ScaleControl();  // 添加比例尺控件
    map.addControl(scaleCtrl);

    //将风场层的显示优先级降到比BMapLabel的低 以不遮挡label的点击
    // $(".BMap_mask").next().children().eq(3).css("z-index","-500");
    //反向镂空合肥市
    function getAera() {
        //网格渲染
        // let bdary = new BMap.Boundary();
        // bdary.get("利辛县", function (rs) {//获取行政区域
        //     let points = getAnnular(rs.boundaries[0])
        //     //添加环形遮罩层
        //     let ply1 = new BMap.Polygon(points, {
        //         strokeColor: "none",
        //         fillColor: "rgba(43, 185, 163)",
        //         fillOpacity: 1,
        //         strokeOpacity: 0.5
        //     }); //建立多边形覆盖物
        //     map.addOverlay(ply1);
        //
        //     //给目标行政区划添加边框，其实就是给目标行政区划添加一个没有填充物的遮罩层
        //     let ply = new BMap.Polygon(rs.boundaries[0], {strokeWeight: 2, strokeColor: "#999", fillColor: ""});
        //     map.addOverlay(ply);
        //     map.setViewport(ply.getPath());//调整视野
        // });
        new BMap.Boundary().get("安徽省", function(rs){
            for(let i=0;i<rs.boundaries.length;i++){
                let ply = new BMap.Polygon(rs.boundaries[i], {
                    strokeWeight: 2,
                    strokeOpacity:1,
                    strokeColor: "#045551"},
                );
                map.addOverlay(ply);
            }
        });
    }
    //处理地图首尾闭合,否则会多出一条线条
    function getAnnular(data) {
        // 环形区域的内部点集合
        let innerPoints = data
        let index = innerPoints.indexOf(";")
        let lastIndex = innerPoints.lastIndexOf(";")
        // 要首尾闭合
        let one = innerPoints.substring(0, index + 1)
        let oneLast = innerPoints.substring(lastIndex + 1)
        if (one !== oneLast) {
            innerPoints += ";" + one
        }

        //自定义外围边框点的集合
        var E_JW = "170, 39;"; //东
        var EN_JW = "170, 81;"; //东北角
        var N_JW = "105, 81;"; //北
        var NW_JW = "-170,  81;"; //西北角
        var W_JW = "-170, 39;"; //西
        var WS_JW = "-170, -68;"; //西南角
        var S_JW = "105, -68;"; //南
        var SE_JW = "170, -68 ;"; //东南角
        // 外围边框点 也要闭合
        let outPoints = E_JW + SE_JW + S_JW + WS_JW + W_JW + NW_JW + N_JW + EN_JW + E_JW
        return innerPoints + outPoints
    }
    function addlabel() {
        // let points=[[115.78919,33.863132],[116.515884,31.765982],
        // [117.228779,31.826871],[115.807588,32.915904],[116.396301,32.877101]]
        let pointArray = [
            new BMap.Point(115.78919,33.863132),
            new BMap.Point(116.515884,31.765982),
            new BMap.Point(117.228779,31.826871),
            new BMap.Point(115.807588,32.915904),
            new BMap.Point(116.396301,32.877101)];
        let contentArray = ['亳州', '六安', '合肥', '阜阳', '阜阳2'];
        for (let i = 0; i < pointArray.length; i++) {
            let opts = {position: pointArray[i], offset: new BMap.Size(0, -0)}
            let label = new BMap.Label(contentArray[i], opts);
            label.setStyle({
                color: "rgba(43, 185, 163)",
                width: "30px",
                fontSize: "14px",
                height: "20px",
                lineHeight: "20px",
                fontFamily: "微软雅黑",
            });
            map.addOverlay(label);
        }
    }
    /**
     * 获取数组中的最大值和最小值函数
     * */
    function getMaxMin(arr,param) {
        try {
            if (param == 'max') {
                if(typeof( Math.max.apply(null, arr))!='number'){
                    return "Error:element in arr is not a number!";
                }else{
                    return Math.max.apply(null, arr);
                }
            }else if (param == 'min') {
                if(typeof( Math.min.apply(null, arr))!='number'){
                    return "Error:element in arr is not a number!";
                }else{
                    return Math.min.apply(null, arr);
                }
            }else{
                return "Error:param is unsupported!";
            }
        } catch (e) {
            return "Error:"+e;
        }
    }

</script>
</body>
</html>
